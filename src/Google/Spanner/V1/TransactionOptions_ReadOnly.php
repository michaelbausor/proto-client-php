<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: google/spanner/v1/transaction.proto

namespace Google\Spanner\V1;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * <pre>
 * Options for read-only transactions.
 * </pre>
 *
 * Protobuf type <code>google.spanner.v1.TransactionOptions.ReadOnly</code>
 */
class TransactionOptions_ReadOnly extends \Google\Protobuf\Internal\Message
{
    /**
     * <pre>
     * If true, the Cloud Spanner-selected read timestamp is included in
     * the [Transaction][google.spanner.v1.Transaction] message that describes the transaction.
     * </pre>
     *
     * <code>bool return_read_timestamp = 6;</code>
     */
    private $return_read_timestamp = false;
    protected $timestamp_bound;

    public function __construct() {
        \GPBMetadata\Google\Spanner\V1\Transaction::initOnce();
        parent::__construct();
    }

    /**
     * <pre>
     * Read at a timestamp where all previously committed transactions
     * are visible.
     * </pre>
     *
     * <code>bool strong = 1;</code>
     */
    public function getStrong()
    {
        return $this->readOneof(1);
    }

    /**
     * <pre>
     * Read at a timestamp where all previously committed transactions
     * are visible.
     * </pre>
     *
     * <code>bool strong = 1;</code>
     */
    public function setStrong($var)
    {
        GPBUtil::checkBool($var);
        $this->writeOneof(1, $var);
    }

    /**
     * <pre>
     * Executes all reads at a timestamp &gt;= `min_read_timestamp`.
     * This is useful for requesting fresher data than some previous
     * read, or data that is fresh enough to observe the effects of some
     * previously committed transaction whose timestamp is known.
     * Note that this option can only be used in single-use transactions.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp min_read_timestamp = 2;</code>
     */
    public function getMinReadTimestamp()
    {
        return $this->readOneof(2);
    }

    /**
     * <pre>
     * Executes all reads at a timestamp &gt;= `min_read_timestamp`.
     * This is useful for requesting fresher data than some previous
     * read, or data that is fresh enough to observe the effects of some
     * previously committed transaction whose timestamp is known.
     * Note that this option can only be used in single-use transactions.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp min_read_timestamp = 2;</code>
     */
    public function setMinReadTimestamp(&$var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Timestamp::class);
        $this->writeOneof(2, $var);
    }

    /**
     * <pre>
     * Read data at a timestamp &gt;= `NOW - max_staleness`
     * seconds. Guarantees that all writes that have committed more
     * than the specified number of seconds ago are visible. Because
     * Cloud Spanner chooses the exact timestamp, this mode works even if
     * the client's local clock is substantially skewed from Cloud Spanner
     * commit timestamps.
     * Useful for reading the freshest data available at a nearby
     * replica, while bounding the possible staleness if the local
     * replica has fallen behind.
     * Note that this option can only be used in single-use
     * transactions.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_staleness = 3;</code>
     */
    public function getMaxStaleness()
    {
        return $this->readOneof(3);
    }

    /**
     * <pre>
     * Read data at a timestamp &gt;= `NOW - max_staleness`
     * seconds. Guarantees that all writes that have committed more
     * than the specified number of seconds ago are visible. Because
     * Cloud Spanner chooses the exact timestamp, this mode works even if
     * the client's local clock is substantially skewed from Cloud Spanner
     * commit timestamps.
     * Useful for reading the freshest data available at a nearby
     * replica, while bounding the possible staleness if the local
     * replica has fallen behind.
     * Note that this option can only be used in single-use
     * transactions.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_staleness = 3;</code>
     */
    public function setMaxStaleness(&$var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Duration::class);
        $this->writeOneof(3, $var);
    }

    /**
     * <pre>
     * Executes all reads at the given timestamp. Unlike other modes,
     * reads at a specific timestamp are repeatable; the same read at
     * the same timestamp always returns the same data. If the
     * timestamp is in the future, the read will block until the
     * specified timestamp, modulo the read's deadline.
     * Useful for large scale consistent reads such as mapreduces, or
     * for coordinating many reads against a consistent snapshot of the
     * data.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp read_timestamp = 4;</code>
     */
    public function getReadTimestamp()
    {
        return $this->readOneof(4);
    }

    /**
     * <pre>
     * Executes all reads at the given timestamp. Unlike other modes,
     * reads at a specific timestamp are repeatable; the same read at
     * the same timestamp always returns the same data. If the
     * timestamp is in the future, the read will block until the
     * specified timestamp, modulo the read's deadline.
     * Useful for large scale consistent reads such as mapreduces, or
     * for coordinating many reads against a consistent snapshot of the
     * data.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp read_timestamp = 4;</code>
     */
    public function setReadTimestamp(&$var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Timestamp::class);
        $this->writeOneof(4, $var);
    }

    /**
     * <pre>
     * Executes all reads at a timestamp that is `exact_staleness`
     * old. The timestamp is chosen soon after the read is started.
     * Guarantees that all writes that have committed more than the
     * specified number of seconds ago are visible. Because Cloud Spanner
     * chooses the exact timestamp, this mode works even if the client's
     * local clock is substantially skewed from Cloud Spanner commit
     * timestamps.
     * Useful for reading at nearby replicas without the distributed
     * timestamp negotiation overhead of `max_staleness`.
     * </pre>
     *
     * <code>.google.protobuf.Duration exact_staleness = 5;</code>
     */
    public function getExactStaleness()
    {
        return $this->readOneof(5);
    }

    /**
     * <pre>
     * Executes all reads at a timestamp that is `exact_staleness`
     * old. The timestamp is chosen soon after the read is started.
     * Guarantees that all writes that have committed more than the
     * specified number of seconds ago are visible. Because Cloud Spanner
     * chooses the exact timestamp, this mode works even if the client's
     * local clock is substantially skewed from Cloud Spanner commit
     * timestamps.
     * Useful for reading at nearby replicas without the distributed
     * timestamp negotiation overhead of `max_staleness`.
     * </pre>
     *
     * <code>.google.protobuf.Duration exact_staleness = 5;</code>
     */
    public function setExactStaleness(&$var)
    {
        GPBUtil::checkMessage($var, \Google\Protobuf\Duration::class);
        $this->writeOneof(5, $var);
    }

    /**
     * <pre>
     * If true, the Cloud Spanner-selected read timestamp is included in
     * the [Transaction][google.spanner.v1.Transaction] message that describes the transaction.
     * </pre>
     *
     * <code>bool return_read_timestamp = 6;</code>
     */
    public function getReturnReadTimestamp()
    {
        return $this->return_read_timestamp;
    }

    /**
     * <pre>
     * If true, the Cloud Spanner-selected read timestamp is included in
     * the [Transaction][google.spanner.v1.Transaction] message that describes the transaction.
     * </pre>
     *
     * <code>bool return_read_timestamp = 6;</code>
     */
    public function setReturnReadTimestamp($var)
    {
        GPBUtil::checkBool($var);
        $this->return_read_timestamp = $var;
    }

    public function getTimestampBound()
    {
        return $this->timestamp_bound;
    }

}

